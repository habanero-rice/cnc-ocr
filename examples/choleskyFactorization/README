Cholesky factorization example for CnC-OCR
==========================================

Follow the instructions in the CnC-OCR README for building and installing the
CnC-OCR runtime and toolchain.

This example includes the following files:

    * Cholesky.cnc:
        Specification for this application's CnC graph structure.

    * Main.c:
        Entry point for the application. Includes the code to initialize the
        CnC graph, as well as handle the result of the graph computation.

    * kComputeStep.c, kjComputeStep.c, kjiComputeStep.c:
        These step functions simply prescribe other steps, but structuring
        the application this way for better parallelism since more tasks
        are started more quickly.

    * s1ComputeStep.c, s2ComputeStep.c, s3ComputeStep.c:
        The step functions corresponding to the Cholesky, Trisolve, and
        Update phases of the Cholesky factorization algorithm, respectively.

    * user_types.h:
        A header included globally in the make process that provides the
        definitions for all non-primitive types referenced in Cholesky.cnc.

    * Makefile:
        The makefile for this example has been slightly modified from the
        default makefile generated by the graph translator.

    * run_test.sh:
        A shell script that runs the translator, makes the application
        binary, runs the application and finally verifies the output.

    * ocr-files/default16th.cfg:
        OCR machine configuration for running with 16 threads (workpiles).

    * ocr-files/LICENSE:
        A copy of the OCR license (required for distributing default16th.cfg).

You must run the CnC-OCR graph translator tool to generate the scaffolding
code, and compile the application using the provided Makefile. You can use
the provided shell script to build and run the application:

        ./run_test.sh

The script runs the Cholesky application twice using a sample 2000x2000 matrix.
The first run uses 16 threads, while the second uses 4 threads. After each run
the script checks the output matrix's checksum to verify the computed results.
A successful run should yield output like the following (the times will vary):

        16 threads                             
        The computation took Q0.502674Q seconds
        Cholesky.out: OK                       
        4 threads                              
        The computation took Q1.528771Q seconds
        Cholesky.out: OK                       
